# Phase 5: Deep Research + Hybrid Solution Generation
# Date: 2026-01-31

## 1. Technical Feasibility Findings

### 1.1 Event Sourcing for LLM Agents — Validated
The event sourcing pattern for AI agents is gaining strong industry traction:
- BoundaryML (Nov 2025): "Treat agent interactions as an event log, not mutable state"
- Akka/Data Mesh Live: "Event sourcing is the backbone of agentic AI"
- Graphite Framework: Full open-source implementation with event-sourced agent workflows
- Confluent: "Every event an agent processes is recorded in a permanent log"

**Key validation**: Multiple independent teams are converging on event sourcing as the
preferred pattern for managing LLM agent state. Our Event Sourcery concept is architecturally
sound and aligned with industry direction.

### 1.2 Background Processing in Claude Code — Constrained
- Claude Code hooks execute shell commands synchronously
- The Agent SDK supports subagents, but spawning LLM calls from hooks risks infinite loops
- **Workaround**: Use lightweight local processing (not LLM calls) in hooks, and defer
  LLM-powered summarization to a separate CLI command or scheduled process
- The `PreCompact` hook payload includes session info but NOT the conversation content
  (content must be captured via the Stop hook incrementally)

**Key constraint**: Background LLM summarization in hooks is risky. The Dual-Mind's "Scribe"
should be local pattern-matching + template-based, NOT a secondary LLM call.

### 1.3 SQLite Hybrid Search — Production Ready
- SQLite FTS5 + sqlite-vec enables hybrid keyword + vector search in a single file
- Reciprocal Rank Fusion (RRF) effectively merges results from both methods
- Python SentenceTransformers (all-MiniLM-L6-v2) provides 384-dim embeddings locally
- Zero external dependencies — runs entirely on the developer's machine
- Sub-5ms retrieval for typical knowledge base sizes (<100K entries)

**Key enabler**: A single SQLite file can serve as both the event store AND the
semantic search index. No external database required.

### 1.4 Claude Code Hook Capabilities — Confirmed
- **PreCompact**: Fires before compaction, can capture session state
- **SessionStart**: Fires on new session or resume, can inject context
- **Stop**: Fires after every Claude response — ideal for incremental capture
- **PostToolUse**: Can observe specific tool calls (file reads, bash commands, etc.)
- All hooks receive structured JSON payloads with session metadata
- Hooks can write to files, run scripts, call local programs

### 1.5 CLAUDE.md as Delivery Mechanism — Optimal
- Claude Code reads CLAUDE.md at session start automatically — zero effort
- Supports both project-level and global-level files
- Can be dynamically generated by hooks
- Token budget is predictable (~150 lines ≈ 2000-3000 tokens)
- **Key insight**: The SessionStart hook can GENERATE a dynamic CLAUDE.md
  section that contains the loaded memory context

---

## 2. Borrowed Ideas from Eliminated Solutions

| Source | Idea | How to Incorporate |
|--------|------|--------------------|
| Cognitive Journal | Human-readable structured entries | Event projections should output readable markdown |
| Memory Palace | Salience scoring + decay | Events get salience scores; decay over time |
| Git-for-Thought | Branch alignment | Context follows git branches automatically |
| Git-for-Thought | Compact HEAD state file | Main projection is a compact state file |
| Memory Palace | Knowledge graph linking | Events link to related events (semantic similarity) |
| claude-cortex | Contradiction detection | Flag conflicting decisions across sessions |

---

## 3. New Hybrid Solution Architectures

### Hybrid A: "Cortex" — Event-Sourced Memory with Projected Briefings

**Core idea**: Event Sourcery's capture + Dual-Mind's briefing generation,
BUT the briefing is generated by PROJECTION (local, fast) not by LLM call.

```
Architecture:

┌─────────────────────────────────────────────────────┐
│                    Claude Code Session               │
│                                                      │
│  SessionStart ──► Load projected briefing into       │
│                   dynamic CLAUDE.md section           │
│                                                      │
│  Stop (each response) ──► Extract events locally     │
│                            (pattern matching, not LLM)│
│                                                      │
│  PreCompact ──► Final event extraction               │
│                  + snapshot creation                  │
│                  + branch state save                  │
└──────────────────────┬──────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────┐
│              Event Store (SQLite)                     │
│                                                      │
│  Events Table:                                       │
│  ┌──────────────────────────────────────────────┐   │
│  │ id | session | type | content | salience |    │   │
│  │    | project | tags | created | accessed |    │   │
│  │    | embedding_vec | git_branch | decay   |    │   │
│  └──────────────────────────────────────────────┘   │
│                                                      │
│  FTS5 Index: Full-text search on content + tags      │
│  Vec Index: Semantic similarity search on embeddings  │
│                                                      │
│  Snapshots Table:                                    │
│  ┌──────────────────────────────────────────────┐   │
│  │ id | session | project | branch | state_md  │   │
│  └──────────────────────────────────────────────┘   │
└──────────────────────┬──────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────┐
│           Projection Engine (Python)                  │
│                                                      │
│  project_briefing(project, branch, token_budget)     │
│    ├── Load latest snapshot                          │
│    ├── Replay events since snapshot                  │
│    ├── Apply salience decay                          │
│    ├── Score by: salience × recency × access_count   │
│    ├── Select top events within token budget          │
│    └── Format as markdown briefing                   │
│                                                      │
│  contextual_briefing(project, user_message)          │
│    ├── Start with project_briefing()                 │
│    ├── Embed user_message locally                    │
│    ├── Hybrid search: FTS5 + vec similarity          │
│    ├── RRF merge top results                         │
│    └── Append relevant context to briefing           │
└─────────────────────────────────────────────────────┘
```

**Event Types:**
```python
class EventType(Enum):
    DECISION_MADE = "decision_made"         # salience: 0.9
    APPROACH_REJECTED = "approach_rejected"  # salience: 0.9
    PLAN_CREATED = "plan_created"           # salience: 0.85
    PLAN_STEP_COMPLETED = "plan_step_done"  # salience: 0.7
    TASK_COMPLETED = "task_completed"       # salience: 0.6
    KNOWLEDGE_ACQUIRED = "knowledge"        # salience: 0.7
    ERROR_RESOLVED = "error_resolved"       # salience: 0.75
    FILE_MODIFIED = "file_modified"         # salience: 0.4
    FILE_EXPLORED = "file_explored"         # salience: 0.3
    COMMAND_RUN = "command_run"             # salience: 0.2
    PREFERENCE_NOTED = "preference"         # salience: 0.8
```

**Event Extraction (local, no LLM):**
Pattern-match on Claude's tool calls and responses:
- `Edit`/`Write` tool → `FILE_MODIFIED` event
- `Read` tool → `FILE_EXPLORED` event
- `Bash` tool → `COMMAND_RUN` event
- Response contains "decided"/"chose"/"picked" → flag for `DECISION_MADE`
- Response contains "rejected"/"instead of"/"rather than" → `APPROACH_REJECTED`
- TodoWrite tool → `PLAN_CREATED` / `PLAN_STEP_COMPLETED` events
- Response contains "learned"/"discovered"/"found that" → `KNOWLEDGE_ACQUIRED`

**Briefing Generation (at SessionStart):**
```markdown
# Session Context — memory-context-claude-ai (branch: main)
## Generated: 2026-01-31 14:30 | Sessions: 12 | Events: 847

## Active Plan
1. ✅ Problem definition
2. ✅ Existing solutions survey
3. ✅ Brainstorm round 1
4. ➡️ Comparison round 1
5. ⬜ Deep research
[source: plan_created @ session-3, updated session-11]

## Key Decisions
- Storage: SQLite (rejected JSON files, PostgreSQL) [session-5]
- Capture: Hook-based automatic (rejected manual) [session-4]
- Architecture: Two-tier (briefing + deep store) [session-7]

## Recent Work (last 3 sessions)
- Session 12: Wrote brainstorm document with 5 solutions
- Session 11: Completed existing solutions survey
- Session 10: Tested claude-cortex, found too complex for our needs

## Relevant Context
[loaded dynamically based on user's first message or recent activity]
```

**Strengths over pure Event Sourcery:**
- No LLM required for event extraction — pattern matching is fast and deterministic
- Projections are token-budget-aware
- Branch alignment from Git-for-Thought

**Strengths over pure Dual-Mind:**
- No secondary API calls — all local processing
- No race condition on startup — briefing is pre-computed or instant
- Event store provides the "Scribe" function without background LLM

---

### Hybrid B: "Engram" — Tiered Memory with Anticipatory Retrieval

**Core idea**: Two-tier (from memory-mcp) + Anticipatory loading (from Dual-Mind),
with events as the capture mechanism and embeddings for retrieval.

```
Architecture:

Tier 1: "The Brief" (~2000 tokens)
  ├── Auto-generated from highest-salience events
  ├── Written to .claude/memory/BRIEF.md at session end
  ├── Injected via CLAUDE.md include at session start
  ├── Always loaded — covers 80% of sessions
  └── Updated every session automatically

Tier 2: "The Vault" (unlimited)
  ├── Full event store in SQLite
  ├── Queryable via MCP server tools
  ├── Claude can request specific memories mid-session
  └── Semantic search (FTS5 + embeddings)

Tier 3: "The Oracle" (anticipatory)
  ├── Reads user's first message at session start
  ├── Generates embeddings locally
  ├── Retrieves top-K relevant events from Tier 2
  ├── Appends to briefing as "Relevant Context" section
  └── Activates ONLY when first message is received

Hooks:
  Stop → Event extraction (local pattern matching)
  PreCompact → Snapshot + Tier 1 regeneration
  SessionStart → Load Tier 1 + prepare Tier 3
  UserPromptSubmit → Trigger Tier 3 (anticipatory retrieval)
```

**The Three-Phase Loading:**
1. **Instant** (SessionStart): Load Tier 1 briefing — always relevant baseline
2. **Reactive** (UserPromptSubmit): Tier 3 queries Vault based on user's message
3. **On-Demand** (mid-session): Claude uses MCP tools to query Tier 2 directly

**Novel element — "Anticipatory Retrieval":**
The `UserPromptSubmit` hook captures the user's FIRST message before Claude sees it.
It then:
1. Generates an embedding of the message
2. Queries the Vault for semantically similar events
3. Appends relevant context to the system prompt BEFORE Claude processes the message

This solves the chicken-and-egg problem: the user's intent is known before context
is loaded, so only relevant context gets injected.

**Strengths:**
- Three-tier loading balances speed and relevance
- Anticipatory retrieval solves the "load what's relevant" problem
- MCP tools give Claude agency to recall specific memories
- 80/20 rule: Tier 1 covers most sessions cheaply

**Weaknesses:**
- UserPromptSubmit hook + embedding + search adds latency to first response
- Three tiers add architectural complexity
- MCP server is an additional process to run

---

### Hybrid C: "Chronicle" — Git-Integrated Event Journal with Smart Projections

**Core idea**: Event Sourcery's typed events + Git-for-Thought's version control +
Cognitive Journal's readability, with projections as the delivery mechanism.

```
Architecture:

.claude-chronicle/  (git-tracked alongside code)
  ├── events.db           (SQLite event store — gitignored)
  ├── chronicle.md        (current state projection — git-tracked)
  ├── decisions.md        (decision log projection — git-tracked)
  ├── plans/
  │   └── active-plan.md  (active plan projection — git-tracked)
  └── branches/
      └── {branch}.md     (per-branch context — git-tracked)

The projections are git-tracked, the event DB is not.
This means:
  - PRs include context changes alongside code changes
  - Code reviewers can see WHAT decisions were made and WHY
  - Branch merges include context merges
  - The event DB is ephemeral — projections are the source of truth
```

**The "Git-Native" Innovation:**
When you create a PR, the `chronicle.md` diff shows what context changed:
```diff
## Architecture Decisions
+ - Added caching layer using Redis (rejected: Memcached, in-memory)
+   Reason: Need shared cache across worker processes

## Current Work
- In-progress: Authentication flow
+ Completed: Authentication flow
+ In-progress: Authorization middleware
```

Code reviewers see not just WHAT code changed, but WHY and WHAT was considered.

**Event capture is the same as Hybrid A** (local pattern matching on tool calls).

**Projections are markdown files**, updated at session end:
- `chronicle.md`: Overall project context state
- `decisions.md`: Chronological decision log with reasoning
- `plans/active-plan.md`: Current plan with progress
- `branches/{name}.md`: Branch-specific context

**Session start loads `chronicle.md` + current branch context.**

**Strengths:**
- Git-native — context lives alongside code
- Reviewable — PRs include decision context
- No MCP server needed — just hooks + files
- Human-editable projections
- Branch alignment is natural

**Weaknesses:**
- No semantic search — loads projections, not queried events
- Projections could grow unbounded without pruning
- Git conflicts in projection files during merges
- No anticipatory loading — loads branch context, not intent-based

---

## 4. Summary of Round 2 Candidates

| Solution | From | Key Innovation | Complexity |
|----------|------|----------------|------------|
| **Hybrid A: Cortex** | Event Sourcery + Dual-Mind | Projected briefings + branch alignment | Medium |
| **Hybrid B: Engram** | Event Sourcery + Dual-Mind + Two-Tier | Three-tier anticipatory retrieval | High |
| **Hybrid C: Chronicle** | Event Sourcery + Git-for-Thought + Journal | Git-native reviewable context | Medium-Low |

Plus the original top 2:
| **Event Sourcery** (original) | Phase 3 | Typed events + projections | Medium-High |
| **Dual-Mind** (original) | Phase 3 | AI-powered briefing | High |

---

## Phase 5 Status: COMPLETE
## New solutions generated: 3 hybrids
## Total candidates for Round 2: 5 (2 original + 3 hybrid)
## Next: Phase 6 — Comparison Round 2
